@page "/Subject/Test/{Name}/{num:int}/{min:int}/{max:int}/{random:bool}"
@inherits MathJaxContentComponentFixed;

@using System.Text.RegularExpressions;
@using System.Web;
@using BlHell_per.Components;
@using BlHell_per.Core.Compat
@using BlHell_per.Core.Questions
@using MathJaxBlazor;

@inject NavigationManager Navigation
@inject HttpClient Http
@inject IJSRuntime JS

<h3>TestingPage - @name @num</h3>

@if (questionsArray == null || questionsArray.Length == 0) 
{
    <div class="d-flex justify-content-center">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
} else 
{
    <div class="question-grid" style="display:grid">
        <MudGrid class="pb-20">
            @for (int i = 0; i < questionsArray.Length; i++)
            {
                int local_i = i;
                Question question = questionsArray[local_i];

                <MudItem xs="12" sm="6" lg="4">
                    <MudPaper>
                        <QuestionView Index="local_i + 1" QuestionModel="@question" QuestionAnsweredCallback="@(this.onQuestionAnswered)" />
                    </MudPaper>
                </MudItem>
            }
        </MudGrid>

        <MudDialog Visible="_testEndDialogVisible">
            <TitleContent>
                <MudText Typo="Typo.h5">
                    Результат
                </MudText>
            </TitleContent>
            <DialogContent>
                @{
                    int wrong = Array.FindAll(statuses, e => e == 0).Count();
                    int right = Array.FindAll(statuses, e => e == 1).Count();
                    int skip = Array.FindAll(statuses, e => e == 2).Count();

                    <MudText Typo="Typo.h6">Ошибочно: <MudChip T="string" Style="font-size:1.4rem" Variant="Variant.Filled" Color="Color.Error">@wrong</MudChip> </MudText>
                    <MudText Typo="Typo.h6">Верно: <MudChip T="string" Style="font-size:1.4rem" Variant="Variant.Filled" Color="Color.Success">@right</MudChip> </MudText>
                    <MudText Typo="Typo.h6">Пропущено: <MudChip T="string" Style="font-size:1.4rem" Variant="Variant.Filled" Color="Color.Warning">@skip</MudChip> </MudText>

                    if (statuses.Count() == 25)
                    {
                        int score = Math.Max((right * 2) - wrong, 0);
                        <MudDivider />
                        <MudText Typo="Typo.h6">Набранный балл: <MudChip T="string" Style="font-size:1.4rem" Variant="Variant.Filled" Color="Color.Primary">@score</MudChip> </MudText>
                        <MudProgressLinear Color="Color.Primary" Value="@(score * 2)" Size="Size.Medium" />
                    }
                }
            </DialogContent>
            <DialogActions>
                <MudButton OnClick="@(e => this._testEndDialogVisible = false)">Закрыть</MudButton>
                <MudButton OnClick="@(e => this.Navigation.ReloadPage())">Повторить</MudButton>
            </DialogActions>
        </MudDialog>

    </div>
}

@code {
    [Parameter]
    public string name { get; set; }

    [Parameter]
    public int num { get; set; }
    [Parameter]
    public int min { get; set; }
    [Parameter]
    public int max { get; set; }

    [Parameter]
    public bool random { get; set; }

    private string[] colors =
    {
        "#c0392b",
        "#2ecc71",
        "#d4ac0d"
    };

    private Question[] questionsArray;

    private int statusesCounter;
    private int[] statuses;

    private bool shouldRender = true;
    private bool _testEndDialogVisible = false;


    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        Task task = new Task(()=> { });
        try 
        { 
            task = base.OnAfterRenderAsync(firstRender); 
        }
        catch (Exception _) {}
        return task;
    }


    protected override async Task OnInitializedAsync()
    {
        SerializationHandler<Question> serializationHandler = 
        await SerializationHandler<Question>.DeserializeAsync($"resources/{name}.json", Http, JS);

        Question[] questions = serializationHandler.Questions.Extract(this.min,this.max);
        if (random) questions.Shuffle();

        this.questionsArray = new Question[this.num];
        Array.Copy(questions,this.questionsArray,this.num);

        this.statuses = new int[this.num];
        Array.Fill(this.statuses,-1);

        //this.questionsArray.Shuffle();
        for (int i = 0; i<this.questionsArray.Length;i++)
        {
            Question q = this.questionsArray[i];
            q.Shuffle();
            q.InsertAnswer("Пропустить вопрос");
        }

        await base.OnInitializedAsync();
    }
    private async void onQuestionAnswered(int status)
    {
        this.statuses[this.statusesCounter++] = status;
        this.shouldRender = Array.FindAll(statuses, e => e == -1).Count() == 0;

        if (this.shouldRender) _testEndDialogVisible = true;
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
    }
    protected override bool ShouldRender()
    {
        if (!this.shouldRender)
        {
            this.shouldRender = true;
            return false;
        }
        return base.ShouldRender();
    }
}
